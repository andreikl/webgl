var jade = require('jade');

var templatizer = {};



// home.jade compiled template
templatizer["home"] = function tmpl_home() {
    return '<ul><li><a href="#/tutorials/tutorial1">Tutorial 1</a></li><li><a href="#/tutorials/tutorial2">Tutorial 2</a></li><li><a href="#/tutorials/tutorial3">Tutorial 3</a></li><li><a href="#/tutorials/tutorial4">Tutorial 4</a></li></ul>';
};

// tutorial1.jade compiled template
templatizer["tutorial1"] = function tmpl_tutorial1() {
    return '<div class="tutorial1"><h1>Example 1</h1><div id="fps">---</div><canvas id="webglcanvas" style="border:none;width:500px;height:500px">Canvas element is not supported</canvas><form id="configure-form"><input type="submit" name="GetSphere" value="Get Sphere"/></form><script id="shader-vs" type="x-shader/x-vertex">attribute vec3 aVertexPosition;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n\nvoid main(void) {\n    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n}\n</script><script id="shader-fs" type="x-shader/x-fragment">precision mediump float;\n\nuniform vec4 uMaterialColor;\n\nvoid main(void) {\n    gl_FragColor = uMaterialColor;\n}</script></div>';
};

// tutorial2.jade compiled template
templatizer["tutorial2"] = function tmpl_tutorial2() {
    return '<div class="tutorial2"><h1>Example 2</h1><div id="fps">---</div><canvas id="webglcanvas" style="border:none;width:500px;height:500px">Canvas element is not supported</canvas><form id="configure-form"><input type="submit" name="GetSphere" value="Get Sphere"/></form><script id="shader-vs" type="x-shader/x-vertex">attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat3 uNMatrix;\n\nvarying vec3 vNormalEyeVector;\nvarying vec3 vVertexEyePosition;\n\nvoid main(void) {\n    // Get the vertex position in eye coordinates\n    vec4 vertexEyePosition4 = uMVMatrix * vec4(aVertexPosition, 1.0);\n    vVertexEyePosition = vertexEyePosition4.xyz / vertexEyePosition4.w;\n\n    // Transform the normal (n) to eye coordinates\n    vNormalEyeVector = normalize(uNMatrix * aVertexNormal);\n\n    gl_Position = uPMatrix * vertexEyePosition4;\n}\n</script><script id="shader-fs" type="x-shader/x-fragment">precision mediump float;\n\nvarying vec3 vNormalEyeVector;\nvarying vec3 vVertexEyePosition;\n\nuniform vec3 uLightPosition;\n\nuniform vec3 uLightAmbient;\nuniform vec3 uLightDiffuse;\nuniform vec3 uLightSpecular;\n\nuniform vec4 uMaterialColor;\nuniform float uMaterialShininess;\n\nvoid main(void) {\n    vec3 normalEyeVector = normalize(vNormalEyeVector);\n\n    // Calculate the vector (l) to the light source\n    vec3 lightVector = normalize(uLightPosition - vVertexEyePosition);\n    // Calculate n dot l for diffuse lighting\n    float diffuseLightWeighting = max(dot(normalEyeVector, lightVector), 0.0);\n\n    float specularLightWeighting = 0.0;\n    if(diffuseLightWeighting > 0.0) {\n        // Calculate the reflection vector (r) that is needed for specular light\n        vec3 reflectionVector = reflect(-lightVector, normalEyeVector);\n        // The camera in eye coordinates is located in the origin and is pointing\n        // along the negative z-axis. Calculate viewVector (v)\n        // in eye coordinates as:\n        // (0.0, 0.0, 0.0) - vVertexEyePosition\n        vec3 eyeVector = -normalize(vVertexEyePosition);\n        float rdotv = max(dot(reflectionVector, eyeVector), 0.0);\n        specularLightWeighting = pow(rdotv, uMaterialShininess);\n    }\n\n    vec3 lightWeighting = uLightAmbient + uLightDiffuse * diffuseLightWeighting + uLightSpecular * specularLightWeighting;\n\n    gl_FragColor = vec4(uMaterialColor.rgb * lightWeighting, uMaterialColor.a);\n}</script></div>';
};

// tutorial4.jade compiled template
templatizer["tutorial4"] = function tmpl_tutorial4() {
    return '<div class="tutorial4"><h1>Example 4</h1><div id="fps">---</div><canvas id="webglcanvas" style="border:none;width:500px;height:500px">Canvas element is not supported</canvas><form id="configure-form"><input type="submit" name="GetSphere" value="Get Sphere"/></form><script id="shader-vs" type="x-shader/x-vertex">attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nattribute vec2 aVertexTexture;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat3 uNMatrix;\n\nvarying vec2 vVertexTexture;\nvarying vec3 vNormalEyeVector;\nvarying vec3 vVertexEyePosition;\n\nvoid main(void) {\n    // Get the vertex position in eye coordinates\n    vec4 vertexEyePosition4 = uMVMatrix * vec4(aVertexPosition, 1.0);\n    vVertexEyePosition = vertexEyePosition4.xyz / vertexEyePosition4.w;\n\n    // Transform the normal (n) to eye coordinates\n    vNormalEyeVector = normalize(uNMatrix * aVertexNormal);\n\n    gl_Position = uPMatrix * vertexEyePosition4;\n    vVertexTexture = aVertexTexture;\n}\n</script><script id="shader-fs" type="x-shader/x-fragment">precision mediump float;\n\nvarying vec2 vVertexTexture;\nvarying vec3 vNormalEyeVector;\nvarying vec3 vVertexEyePosition;\n\nuniform vec3 uLightPosition;\n\nuniform vec3 uLightAmbient;\nuniform vec3 uLightDiffuse;\nuniform vec3 uLightSpecular;\n\nuniform float uMaterialShininess;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    vec3 normalEyeVector = normalize(vNormalEyeVector);\n\n    // Calculate the vector (l) to the light source\n    vec3 lightVector = normalize(uLightPosition - vVertexEyePosition);\n    // Calculate n dot l for diffuse lighting\n    float diffuseLightWeighting = max(dot(normalEyeVector, lightVector), 0.0);\n\n    float specularLightWeighting = 0.0;\n    if(diffuseLightWeighting > 0.0) {\n        // Calculate the reflection vector (r) that is needed for specular light\n        vec3 reflectionVector = reflect(-lightVector, normalEyeVector);\n        // The camera in eye coordinates is located in the origin and is pointing\n        // along the negative z-axis. Calculate viewVector (v)\n        // in eye coordinates as:\n        // (0.0, 0.0, 0.0) - vVertexEyePosition\n        vec3 eyeVector = -normalize(vVertexEyePosition);\n        float rdotv = max(dot(reflectionVector, eyeVector), 0.0);\n        specularLightWeighting = pow(rdotv, uMaterialShininess);\n    }\n\n    vec3 lightWeighting = uLightAmbient + uLightDiffuse * diffuseLightWeighting + uLightSpecular * specularLightWeighting;\n\n    vec4 texelColor = texture2D(uSampler, vVertexTexture);\n    gl_FragColor = vec4(texelColor.rgb * lightWeighting, texelColor.a);\n}</script></div>';
};

// tutorial3.jade compiled template
templatizer["tutorial3"] = function tmpl_tutorial3() {
    return '<div class="tutorial3"><h1>Example 3</h1><div id="fps">---</div><canvas id="webglcanvas" style="border:none;width:500px;height:500px">Canvas element is not supported</canvas><form id="configure-form"><input type="submit" name="GetSphere" value="Get Sphere"/></form><script id="shader-vs" type="x-shader/x-vertex">attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nattribute vec2 aVertexTexture;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat3 uNMatrix;\n\nvarying vec2 vVertexTexture;\nvarying vec3 vNormalEyeVector;\nvarying vec3 vVertexEyePosition;\n\nvoid main(void) {\n    // Get the vertex position in eye coordinates\n    vec4 vertexEyePosition4 = uMVMatrix * vec4(aVertexPosition, 1.0);\n    vVertexEyePosition = vertexEyePosition4.xyz / vertexEyePosition4.w;\n\n    // Transform the normal (n) to eye coordinates\n    vNormalEyeVector = normalize(uNMatrix * aVertexNormal);\n\n    gl_Position = uPMatrix * vertexEyePosition4;\n    vVertexTexture = aVertexTexture;\n}\n</script><script id="shader-fs" type="x-shader/x-fragment">precision mediump float;\n\nvarying vec2 vVertexTexture;\nvarying vec3 vNormalEyeVector;\nvarying vec3 vVertexEyePosition;\n\nuniform vec3 uLightPosition;\n\nuniform vec3 uLightAmbient;\nuniform vec3 uLightDiffuse;\nuniform vec3 uLightSpecular;\n\nuniform float uMaterialShininess;\nuniform sampler2D uSampler;\n\nvoid main(void) {\n    vec3 normalEyeVector = normalize(vNormalEyeVector);\n\n    // Calculate the vector (l) to the light source\n    vec3 lightVector = normalize(uLightPosition - vVertexEyePosition);\n    // Calculate n dot l for diffuse lighting\n    float diffuseLightWeighting = max(dot(normalEyeVector, lightVector), 0.0);\n\n    float specularLightWeighting = 0.0;\n    if(diffuseLightWeighting > 0.0) {\n        // Calculate the reflection vector (r) that is needed for specular light\n        vec3 reflectionVector = reflect(-lightVector, normalEyeVector);\n        // The camera in eye coordinates is located in the origin and is pointing\n        // along the negative z-axis. Calculate viewVector (v)\n        // in eye coordinates as:\n        // (0.0, 0.0, 0.0) - vVertexEyePosition\n        vec3 eyeVector = -normalize(vVertexEyePosition);\n        float rdotv = max(dot(reflectionVector, eyeVector), 0.0);\n        specularLightWeighting = pow(rdotv, uMaterialShininess);\n    }\n\n    vec3 lightWeighting = uLightAmbient + uLightDiffuse * diffuseLightWeighting + uLightSpecular * specularLightWeighting;\n\n    vec4 texelColor = texture2D(uSampler, vVertexTexture);\n    gl_FragColor = vec4(texelColor.rgb * lightWeighting, texelColor.a);\n}</script></div>';
};


module.exports = templatizer;
